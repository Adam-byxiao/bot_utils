# Network Monitor 用户指南

## 目录

1. [项目简介](#项目简介)
2. [系统要求](#系统要求)
3. [安装配置](#安装配置)
4. [快速开始](#快速开始)
5. [详细功能说明](#详细功能说明)
6. [配置选项](#配置选项)
7. [数据过滤](#数据过滤)
8. [数据导出](#数据导出)
9. [编程接口](#编程接口)
10. [示例和最佳实践](#示例和最佳实践)
11. [故障排除](#故障排除)
12. [常见问题](#常见问题)

---

## 项目简介

Network Monitor 是一个基于 Chrome DevTools Protocol 的网络监控工具，能够实时捕获、分析和导出网络请求数据。该工具特别适用于：

- **Web 应用性能分析**：监控页面加载时的网络请求
- **API 调试和测试**：跟踪 API 请求和响应
- **网络流量分析**：分析应用的网络使用模式
- **自动化测试**：在测试过程中收集网络数据

### 核心特性

- ✅ **实时网络监控**：通过 Chrome DevTools Protocol 实时捕获网络数据
- ✅ **智能数据过滤**：支持多种过滤规则，排除无关请求
- ✅ **数据标准化**：将原始网络数据转换为统一格式
- ✅ **多格式导出**：支持 JSON、CSV、Excel、TXT 等格式
- ✅ **详细报告**：生成包含统计信息的分析报告
- ✅ **灵活配置**：通过配置文件自定义监控行为
- ✅ **编程接口**：提供 Python API 用于集成到其他项目

---

## 系统要求

### 基础要求

- **Python**: 3.7 或更高版本
- **Chrome 浏览器**: 支持 DevTools Protocol 的版本
- **操作系统**: Windows、macOS、Linux

### 依赖包

#### 核心依赖
- `websockets` - WebSocket 通信
- `aiohttp` - 异步 HTTP 客户端

#### 数据处理
- `pandas` - 数据分析和处理
- `openpyxl` - Excel 文件支持

#### 配置和日志
- `pyyaml` - YAML 配置文件支持

#### 可选依赖
- `requests` - HTTP 请求库
- `beautifulsoup4` - HTML 解析
- `lxml` - XML 解析器

#### 开发依赖
- `pytest` - 单元测试
- `pytest-asyncio` - 异步测试支持
- `black` - 代码格式化
- `flake8` - 代码检查

---

## 安装配置

### 1. 克隆项目

```bash
git clone <repository-url>
cd network_monitor
```

### 2. 安装依赖

```bash
pip install -r requirements.txt
```

### 3. 启动 Chrome 调试模式

在使用 Network Monitor 之前，需要以调试模式启动 Chrome：

#### Windows
```cmd
chrome.exe --remote-debugging-port=9222 --user-data-dir=temp
```

#### macOS
```bash
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222 --user-data-dir=/tmp/chrome_dev_test
```

#### Linux
```bash
google-chrome --remote-debugging-port=9222 --user-data-dir=/tmp/chrome_dev_test
```

### 4. 验证安装

运行测试脚本验证安装：

```bash
python examples.py
```

---

## 快速开始

### 基本使用

1. **启动 Chrome 调试模式**（参见安装配置）

2. **运行基本监控**：

```bash
python main.py
```

3. **在 Chrome 中访问目标网站**，Network Monitor 将自动捕获网络请求

4. **停止监控**：按 `Ctrl+C` 停止监控

5. **查看结果**：在 `output` 目录中查看生成的数据文件

### 命令行选项

```bash
# 使用默认配置监控 30 秒
python main.py --duration 30

# 使用自定义配置文件
python main.py --config custom_config.json

# 指定输出目录
python main.py --output ./my_output

# 启用详细日志
python main.py --verbose

# 创建默认配置文件
python main.py --create-config
```

### 第一次使用示例

```bash
# 1. 启动 Chrome 调试模式
chrome.exe --remote-debugging-port=9222 --user-data-dir=temp

# 2. 运行监控（监控 60 秒）
python main.py --duration 60 --verbose

# 3. 在 Chrome 中访问 https://example.com

# 4. 查看结果
ls output/
```

---

## 详细功能说明

### 网络数据捕获

Network Monitor 通过 Chrome DevTools Protocol 捕获以下网络数据：

#### 请求信息
- URL 和域名
- HTTP 方法（GET、POST 等）
- 请求头
- 请求体数据
- 查询参数
- 时间戳

#### 响应信息
- 状态码和状态文本
- 响应头
- 响应体数据
- 内容类型
- 响应时间
- 数据大小

#### 事务信息
- 请求-响应配对
- 总耗时
- 成功/失败状态
- 错误信息

### 数据标准化

原始的 Chrome DevTools 数据会被转换为标准化格式：

```json
{
  "transaction_id": "unique-id",
  "session_id": "session-123",
  "timestamp": "2024-01-01T12:00:00Z",
  "duration_ms": 150.5,
  "success": true,
  "request": {
    "method": "GET",
    "url": "https://api.example.com/v1/users",
    "domain": "api.example.com",
    "path": "/v1/users",
    "endpoint": "/v1/users",
    "is_api": true,
    "headers": {...},
    "query_params": {...}
  },
  "response": {
    "status_code": 200,
    "status_category": "success",
    "content_type": "application/json",
    "is_json": true,
    "headers": {...},
    "data": {...}
  },
  "tags": ["api", "method:get", "status:success"]
}
```

---

## 配置选项

### 配置文件结构

Network Monitor 使用 JSON 格式的配置文件：

```json
{
  "chrome": {
    "host": "localhost",
    "port": 9222,
    "session_id": null
  },
  "output": {
    "dir": "./output"
  },
  "filters": {
    "exclude_static_resources": true,
    "api_only": false,
    "exclude_status_codes": [404, 500],
    "include_domains": []
  },
  "export": {
    "formats": ["json", "csv", "excel"],
    "include_summary": true
  }
}
```

### 详细配置说明

#### Chrome 连接配置
- `chrome.host`: Chrome DevTools 主机地址（默认：localhost）
- `chrome.port`: Chrome DevTools 端口（默认：9222）
- `chrome.session_id`: 特定会话 ID（可选）

#### 输出配置
- `output.dir`: 输出文件目录（默认：./output）

#### 过滤器配置
- `filters.exclude_static_resources`: 排除静态资源（CSS、JS、图片等）
- `filters.api_only`: 仅捕获 API 请求
- `filters.exclude_status_codes`: 排除特定状态码的请求
- `filters.include_domains`: 仅包含特定域名的请求

#### 导出配置
- `export.formats`: 导出格式列表
- `export.include_summary`: 是否包含摘要报告

### 配置示例

#### 仅监控 API 请求
```json
{
  "filters": {
    "exclude_static_resources": true,
    "api_only": true,
    "exclude_status_codes": [404, 500]
  },
  "export": {
    "formats": ["json", "excel"],
    "include_summary": true
  }
}
```

#### 监控特定域名
```json
{
  "filters": {
    "include_domains": ["api.example.com", "backend.myapp.com"],
    "exclude_static_resources": true
  }
}
```

#### 排除错误请求
```json
{
  "filters": {
    "exclude_status_codes": [400, 401, 403, 404, 500, 502, 503]
  }
}
```

---

## 数据过滤

### 内置过滤规则

Network Monitor 提供多种内置过滤规则：

#### 1. 静态资源过滤
自动排除常见的静态资源：
- CSS 文件 (`.css`)
- JavaScript 文件 (`.js`)
- 图片文件 (`.png`, `.jpg`, `.gif`, `.svg` 等)
- 字体文件 (`.woff`, `.ttf` 等)
- 媒体文件 (`.mp4`, `.mp3` 等)

#### 2. API 请求识别
自动识别 API 请求：
- URL 包含 `/api/`
- URL 包含版本号 `/v1/`, `/v2/` 等
- URL 以 `.json` 结尾
- GraphQL 端点 `/graphql`
- REST 端点 `/rest/`

#### 3. 状态码过滤
根据 HTTP 状态码过滤：
- 成功请求：2xx
- 重定向：3xx
- 客户端错误：4xx
- 服务器错误：5xx

#### 4. 域名过滤
- 包含特定域名
- 排除特定域名
- 支持通配符匹配

### 自定义过滤规则

可以添加自定义过滤规则：

```python
from data_filter import DataFilter, FilterRule

# 创建过滤器
filter = DataFilter()

# 添加自定义规则
custom_rule = FilterRule(
    name="exclude_analytics",
    rule_type="exclude",
    field="url",
    pattern=r"(google-analytics|gtag|facebook\.com/tr)",
    is_regex=True
)

filter.add_rule(custom_rule)
```

### 过滤统计

过滤器会提供详细的统计信息：

```python
stats = filter.get_stats()
print(f"总请求数: {stats.total_requests}")
print(f"过滤后请求数: {stats.filtered_requests}")
print(f"重复请求数: {stats.duplicate_requests}")
print(f"静态资源数: {stats.static_resources}")
print(f"API 请求数: {stats.api_requests}")
print(f"错误请求数: {stats.error_requests}")
```

---

## 数据导出

### 支持的导出格式

#### 1. JSON 格式
- 完整的数据结构
- 包含元数据信息
- 易于程序处理

```json
{
  "metadata": {
    "export_time": "2024-01-01T12:00:00",
    "total_transactions": 150,
    "format_version": "1.0"
  },
  "transactions": [...]
}
```

#### 2. CSV 格式
- 扁平化的数据结构
- 易于在 Excel 中查看
- 适合数据分析

#### 3. Excel 格式
- 多个工作表
- 包含摘要统计
- 格式化的数据展示

工作表包括：
- `Transactions`: 详细事务数据
- `Summary`: 总体统计信息
- `API_Stats`: API 请求统计
- `Error_Stats`: 错误统计

#### 4. TXT 格式
- 人类可读的文本格式
- 适合快速查看
- 包含关键信息摘要

### 导出示例

```python
from data_exporter import DataExporter

exporter = DataExporter("./output")

# 导出为 JSON
json_file = exporter.export_transactions(transactions, 'json')

# 导出为 Excel（包含多个工作表）
excel_file = exporter.export_transactions(transactions, 'excel')

# 导出摘要报告
summary_file = exporter.export_summary_report(transactions)
```

### 摘要报告

摘要报告包含以下统计信息：

- **总体统计**：请求总数、成功率、平均响应时间
- **状态码分布**：各状态码的请求数量
- **域名统计**：各域名的请求分布
- **API 统计**：API 端点的调用情况
- **错误分析**：错误类型和频率
- **性能指标**：响应时间分布

---

## 编程接口

### 基本用法

```python
from main import NetworkMonitor
import asyncio

async def main():
    # 创建监控器
    monitor = NetworkMonitor()
    
    # 开始监控
    await monitor.start_monitoring()
    
    # 监控 30 秒
    await asyncio.sleep(30)
    
    # 停止监控并导出数据
    transactions = await monitor.stop_monitoring()
    
    # 导出数据
    await monitor.export_data(transactions, ['json', 'excel'])

# 运行
asyncio.run(main())
```

### 自定义事件处理

```python
class CustomNetworkMonitor(NetworkMonitor):
    async def on_request_received(self, request_data):
        """请求接收时的回调"""
        print(f"收到请求: {request_data['url']}")
    
    async def on_response_received(self, response_data):
        """响应接收时的回调"""
        print(f"收到响应: {response_data['status']}")
    
    async def on_transaction_complete(self, transaction):
        """事务完成时的回调"""
        if transaction.response.status_code >= 400:
            print(f"错误请求: {transaction.request.url}")
```

### 高级配置

```python
# 自定义配置
config = {
    "chrome": {"host": "localhost", "port": 9222},
    "filters": {
        "exclude_static_resources": True,
        "api_only": True
    },
    "export": {
        "formats": ["json", "excel"],
        "include_summary": True
    }
}

monitor = NetworkMonitor(config)
```

### 批量处理

```python
async def batch_monitor_sessions(urls, duration=60):
    """批量监控多个会话"""
    results = []
    
    for url in urls:
        monitor = NetworkMonitor()
        await monitor.start_monitoring()
        
        # 在新标签页中打开 URL
        await monitor.navigate_to(url)
        await asyncio.sleep(duration)
        
        transactions = await monitor.stop_monitoring()
        results.append({
            'url': url,
            'transactions': transactions
        })
    
    return results
```

---

## 示例和最佳实践

### 示例 1：基本网络监控

```python
"""
基本网络监控示例
监控所有网络请求并导出为多种格式
"""
import asyncio
from main import NetworkMonitor

async def basic_monitoring():
    monitor = NetworkMonitor()
    
    print("开始网络监控...")
    await monitor.start_monitoring()
    
    # 监控 60 秒
    print("监控中... (60秒)")
    await asyncio.sleep(60)
    
    print("停止监控并导出数据...")
    transactions = await monitor.stop_monitoring()
    
    # 导出多种格式
    await monitor.export_data(transactions, ['json', 'csv', 'excel'])
    
    print(f"监控完成，共捕获 {len(transactions)} 个网络事务")

if __name__ == "__main__":
    asyncio.run(basic_monitoring())
```

### 示例 2：API 请求监控

```python
"""
专门监控 API 请求
过滤掉静态资源，只关注 API 调用
"""
import asyncio
from main import NetworkMonitor

async def api_monitoring():
    # 配置仅监控 API 请求
    config = {
        "filters": {
            "exclude_static_resources": True,
            "api_only": True,
            "exclude_status_codes": [404]
        },
        "export": {
            "formats": ["json", "excel"],
            "include_summary": True
        }
    }
    
    monitor = NetworkMonitor(config)
    
    print("开始 API 监控...")
    await monitor.start_monitoring()
    
    # 监控 120 秒
    await asyncio.sleep(120)
    
    transactions = await monitor.stop_monitoring()
    
    # 分析 API 调用
    api_calls = [t for t in transactions if t.request.is_api]
    print(f"捕获到 {len(api_calls)} 个 API 调用")
    
    # 统计 API 端点
    endpoints = {}
    for call in api_calls:
        endpoint = call.request.endpoint
        endpoints[endpoint] = endpoints.get(endpoint, 0) + 1
    
    print("API 端点调用统计:")
    for endpoint, count in sorted(endpoints.items(), key=lambda x: x[1], reverse=True):
        print(f"  {endpoint}: {count} 次")

if __name__ == "__main__":
    asyncio.run(api_monitoring())
```

### 示例 3：特定域名监控

```python
"""
监控特定域名的网络请求
适用于分析特定服务的网络行为
"""
import asyncio
from main import NetworkMonitor

async def domain_specific_monitoring():
    # 配置监控特定域名
    config = {
        "filters": {
            "include_domains": ["api.github.com", "api.stackoverflow.com"],
            "exclude_static_resources": True
        }
    }
    
    monitor = NetworkMonitor(config)
    
    await monitor.start_monitoring()
    await asyncio.sleep(90)
    transactions = await monitor.stop_monitoring()
    
    # 按域名分组统计
    domain_stats = {}
    for transaction in transactions:
        domain = transaction.request.domain
        if domain not in domain_stats:
            domain_stats[domain] = {
                'total': 0,
                'success': 0,
                'error': 0,
                'avg_duration': 0
            }
        
        stats = domain_stats[domain]
        stats['total'] += 1
        
        if transaction.response.is_success:
            stats['success'] += 1
        else:
            stats['error'] += 1
        
        stats['avg_duration'] = (stats['avg_duration'] * (stats['total'] - 1) + transaction.duration_ms) / stats['total']
    
    # 输出统计结果
    print("域名统计:")
    for domain, stats in domain_stats.items():
        success_rate = (stats['success'] / stats['total']) * 100
        print(f"{domain}:")
        print(f"  总请求: {stats['total']}")
        print(f"  成功率: {success_rate:.1f}%")
        print(f"  平均耗时: {stats['avg_duration']:.1f}ms")

if __name__ == "__main__":
    asyncio.run(domain_specific_monitoring())
```

### 示例 4：错误请求监控

```python
"""
专门监控和分析错误请求
帮助识别网络问题和 API 错误
"""
import asyncio
from main import NetworkMonitor

async def error_monitoring():
    monitor = NetworkMonitor()
    
    # 自定义错误处理
    class ErrorTracker(NetworkMonitor):
        def __init__(self):
            super().__init__()
            self.errors = []
        
        async def on_transaction_complete(self, transaction):
            if not transaction.response.is_success:
                self.errors.append({
                    'url': transaction.request.url,
                    'method': transaction.request.method,
                    'status': transaction.response.status_code,
                    'error': transaction.error,
                    'timestamp': transaction.request.timestamp
                })
    
    error_tracker = ErrorTracker()
    
    await error_tracker.start_monitoring()
    await asyncio.sleep(120)
    transactions = await error_tracker.stop_monitoring()
    
    # 分析错误
    print(f"总请求数: {len(transactions)}")
    print(f"错误请求数: {len(error_tracker.errors)}")
    
    if error_tracker.errors:
        print("\n错误详情:")
        for error in error_tracker.errors[:10]:  # 显示前10个错误
            print(f"  {error['method']} {error['url']} -> {error['status']}")

if __name__ == "__main__":
    asyncio.run(error_monitoring())
```

### 最佳实践

#### 1. 监控时长建议
- **快速测试**: 30-60 秒
- **功能测试**: 2-5 分钟
- **性能测试**: 10-30 分钟
- **长期监控**: 1 小时以上

#### 2. 过滤器配置建议
- 总是启用 `exclude_static_resources` 除非需要分析静态资源
- 对于 API 测试，启用 `api_only`
- 排除不相关的状态码（如 404）
- 使用域名过滤专注于特定服务

#### 3. 数据导出建议
- JSON 格式用于程序处理
- Excel 格式用于人工分析
- 总是包含摘要报告
- 定期清理输出目录

#### 4. 性能优化建议
- 避免长时间监控大量请求
- 使用过滤器减少数据量
- 定期导出和清理数据
- 监控 Chrome 内存使用

#### 5. 安全注意事项
- 不要在生产环境中启用调试模式
- 注意敏感数据的处理
- 定期清理临时文件
- 避免记录敏感的请求头和响应数据

---

## 故障排除

### 常见问题及解决方案

#### 1. 无法连接到 Chrome DevTools

**问题**: `ConnectionRefusedError` 或连接超时

**解决方案**:
1. 确认 Chrome 已以调试模式启动：
   ```bash
   chrome.exe --remote-debugging-port=9222 --user-data-dir=temp
   ```

2. 检查端口是否被占用：
   ```bash
   netstat -an | findstr 9222
   ```

3. 尝试不同的端口：
   ```bash
   chrome.exe --remote-debugging-port=9223 --user-data-dir=temp
   ```

4. 检查防火墙设置

#### 2. 捕获不到网络请求

**问题**: 监控运行但没有捕获到数据

**解决方案**:
1. 确认在正确的 Chrome 实例中浏览网页
2. 检查过滤器配置是否过于严格
3. 启用详细日志查看详细信息：
   ```bash
   python main.py --verbose
   ```

4. 检查网络请求是否被浏览器缓存

#### 3. 数据导出失败

**问题**: 导出过程中出现错误

**解决方案**:
1. 检查输出目录权限
2. 确认依赖包已正确安装：
   ```bash
   pip install pandas openpyxl
   ```

3. 检查磁盘空间
4. 尝试导出为不同格式

#### 4. 内存使用过高

**问题**: 长时间监控导致内存不足

**解决方案**:
1. 减少监控时长
2. 启用更严格的过滤器
3. 定期导出和清理数据
4. 增加系统内存

#### 5. Chrome 崩溃或无响应

**问题**: Chrome 在监控过程中崩溃

**解决方案**:
1. 重启 Chrome 调试实例
2. 清理用户数据目录
3. 更新 Chrome 到最新版本
4. 检查系统资源使用情况

### 调试模式

启用详细日志进行调试：

```bash
python main.py --verbose --log-level DEBUG
```

或在代码中启用：

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

### 日志文件

检查日志文件获取详细错误信息：

```bash
# 查看最新日志
tail -f network_monitor.log

# 搜索错误信息
grep -i error network_monitor.log
```

---

## 常见问题

### Q1: 支持哪些浏览器？
**A**: 目前仅支持 Chrome 和基于 Chromium 的浏览器（如 Edge、Brave）。Firefox 和 Safari 不支持。

### Q2: 可以监控 HTTPS 请求吗？
**A**: 是的，可以监控所有类型的 HTTP/HTTPS 请求，包括 WebSocket 连接。

### Q3: 如何监控移动端应用？
**A**: 可以通过 Chrome 的远程调试功能监控移动端 WebView，但需要额外配置。

### Q4: 数据会被发送到外部服务器吗？
**A**: 不会。所有数据都在本地处理和存储，不会发送到任何外部服务器。

### Q5: 可以同时监控多个标签页吗？
**A**: 是的，默认会监控所有标签页的网络请求。可以通过配置限制特定标签页。

### Q6: 如何处理大量数据？
**A**: 建议使用过滤器减少数据量，定期导出数据，或使用流式处理模式。

### Q7: 支持实时数据分析吗？
**A**: 支持。可以通过编程接口实现实时数据处理和分析。

### Q8: 如何集成到 CI/CD 流程？
**A**: 可以通过命令行接口和编程 API 集成到自动化测试和 CI/CD 流程中。

### Q9: 有性能影响吗？
**A**: 对浏览器性能影响很小，但长时间监控大量请求可能会占用一些系统资源。

### Q10: 如何贡献代码？
**A**: 欢迎提交 Pull Request。请先阅读贡献指南并确保代码通过所有测试。

---

## 技术支持

如果遇到问题或需要帮助，请：

1. 查看本用户指南的故障排除部分
2. 检查项目的 GitHub Issues
3. 提交新的 Issue 并提供详细信息
4. 联系项目维护者

---

**最后更新**: 2024年1月
**版本**: 1.0.0